#!/bin/bash

#version="$Id: $"

# ___ Help _____________________________________________________________________

if [ $# -ne 6 ]
then
    This=`echo $0 | sed "s/^.*\///g"`
cat<<__END_OF_HELP__
Usage: $This <WorkDir> <ExtCellsMap1> <IntCellsMap2> <ExtCellsMap2>
        "<BSCCells> [<BSCCells> ...]" "<BSCCells> [<BSCCells> ...]"

where
 WorkDir
    The directory path where the result three map file (ExtCellsMap1, 
    IntCellsMap2, ExtCellsMap2) will be genearated and where the temporary
    files will be stored.
 ExtCellsMapPath1
    The map of external GSM cells on side 1 from original cell names and CGI
    values to the new cell names and CGI values.
    This file must be generated by the gen_gsm_map.sh script.
 IntCellsMapPath2
    The map of internal GSM cells on side 2 from original cell names and CGI
    values to the new CGI values.
    This file must be generated by the gen_gsm_map.sh script.
 ExtCellsMapPath2
    The map of external GSM cells on side 2 from original cell names and CGI
    values to the new cell names and CGI values.
    This file must be generated by the gen_gsm_map.sh script.
 BSCCells
    The list of internal GSM, external GSM and external UTRAN cells defined in
    a BSC node.
    This file must be generated by a list_BSC_cells*.sh script.

Example:
 $This ./test/work_data/
    ./test/work_data/cells.EXT.side1.map.csv
    ./test/work_data/cells.INT.side2.map.csv
    ./test/work_data/cells.EXT.side2.map.csv
    "./test/work_data/Side1Sim1/BSC11.BSCCells ./test/work_data/Side1Sim2/BSC12.BSCCells"
    "./test/work_data/Side2Sim1/BSC21.BSCCells ./test/work_data/Side2Sim2/BSC22.BSCCells"

DESCRIPTION:
 In the working directory there will be placed four file with the list of
 internal/external GSM cells from side 1/2 that contain the cell names and CGI
 values only.

 Map the cells on the two GSM sides with each other. In the working directory
 three CVS file will be placed with the mapped cell names and CGI values:
  - Map for internal GSM cells on side 2:
        Find the corresponding twin internal GSM cell on the side 1 and create
        a map with the cell name, CGI value and the twin's CGI value.
  - Map for enternal GSM cells on side 1:
        Find the corresponding twin external GSM cell on the side 2 and create
        a map with the cell name, CGI value and the twin's cell name and the
        mapped CGI value of the internal GSM cell that the twin external GSM
        cell refers.
  - Map for enternal GSM cells on side 2:
        Find the corresponding twin external GSM cell on the side 1 and create
        a map with the cell name, CGI value and the twin's cell name and CGI
        value.

 All informations are fetched from the original lists of cells defined in the
 BSC nodes.

__END_OF_HELP__
exit 1
fi


# ___ Parameters _______________________________________________________________

# Parameters
WorkDir=$1
ExtCellsMap1=$2
IntCellsMap2=$3
ExtCellsMap2=$4
Side1CellsPathes=$5
Side2CellsPathes=$6


# ___ Main activity ____________________________________________________________

#
cat $Side1CellsPathes | grep ",celltype=INT," | cut -d , -f 5,6 | tr "=" "," |
    cut -d , -f 2,4 | sort > $WorkDir/cells.INT.side1.csv
cat $Side2CellsPathes | grep ",celltype=INT," | cut -d , -f 5,6 | tr "=" "," |
    cut -d , -f 2,4 | sort > $WorkDir/cells.INT.side2.csv
cat $Side1CellsPathes | grep ",celltype=EXT," | cut -d , -f 5,6 | tr "=" "," |
    cut -d , -f 2,4 | sort -u > $WorkDir/cells.EXT.side1.csv
cat $Side2CellsPathes | grep ",celltype=EXT," | cut -d , -f 5,6 | tr "=" "," |
    cut -d , -f 2,4 | sort -u > $WorkDir/cells.EXT.side2.csv

# Check number of cells on sides
NumIntCells1=`cat $WorkDir/cells.INT.side1.csv | wc -l`
NumIntCells2=`cat $WorkDir/cells.INT.side2.csv | wc -l`
NumExtCells1=`cat $WorkDir/cells.EXT.side1.csv | wc -l`
NumExtCells2=`cat $WorkDir/cells.EXT.side2.csv | wc -l`

echo "Number os internal cells and external cells on side 1: $NumIntCells1 $NumExtCells1"
echo "Number os internal cells and external cells on side 2: $NumIntCells2 $NumExtCells2"
if [ $NumIntCells1 -ne $NumIntCells2 ]
then
    echo "ERROR: Number of intertnal cells must equal between sides!"
    exit 1
fi
if [ $NumExtCells1 -ne $NumExtCells2 ]
then
    echo "ERROR: Number of extertnal cells must equal between sides!"
    exit 1
fi
if [ $NumIntCells1 -lt $NumExtCells1 ]
then
    echo "ERROR: Number of internal cells must greater or equal then nuber of external cells in side 1!"
    exit 1
fi
if [ $NumIntCells2 -lt $NumExtCells2 ]
then
    echo "ERROR: Number of internal cells must greater or equal then nuber of external cells in side 2!"
    exit 1
fi

# Check unique cell names between two side
MultiCells=`cat $WorkDir/cells.INT.side1.csv $WorkDir/cells.INT.side2.csv |
    cut -d , -f 1 | sort | uniq -c | awk '{print $1,$2}' |
    sort -n | grep -v "^1 "`
NumMultiCells=`echo $MultiCells | wc -w`
echo "GSM cell names with multiple occurence within both side: $NumMultiCells"
echo $MultiCells | tr " " "\n"
echo ""

if [ $NumMultiCells -ne 0 ]
then
    echo "ERROR: GSM cell names must be unique within both side!"
    exit 1
fi

# Show some statistics
echo "Side 1"
echo "  Name:      `cat $WorkDir/cells.INT.side1.csv | cut -d , -f 1 | sort | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  PLMNs:     `cat $WorkDir/cells.INT.side1.csv | tr "-" "," | cut -d , -f 2,3     | sort -n -t , | tr "," "-"  | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  LACs:      `cat $WorkDir/cells.INT.side1.csv | tr "-" "," | cut -d , -f 2       | sort -n      | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  PLMN-LACs: `cat $WorkDir/cells.INT.side1.csv | tr "-" "," | cut -d , -f 2,3,4   | sort -n -t , | tr "," "-"  | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  CIDs:      `cat $WorkDir/cells.INT.side1.csv | tr "-" "," | cut -d , -f 5       | sort -n      | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  CGIs:      `cat $WorkDir/cells.INT.side1.csv | tr "-" "," | cut -d , -f 2,3,4,5 | sort -n -t , | tr "," "-"  | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo ""
echo "Side 2"
echo "  Name:      `cat $WorkDir/cells.INT.side2.csv | cut -d , -f 1 | sort | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  PLMNs:     `cat $WorkDir/cells.INT.side2.csv | tr "-" "," | cut -d , -f 2,3     | sort -n -t , | tr "," "-"  | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  LACs:      `cat $WorkDir/cells.INT.side2.csv | tr "-" "," | cut -d , -f 2       | sort -n      | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  PLMN-LACs: `cat $WorkDir/cells.INT.side2.csv | tr "-" "," | cut -d , -f 2,3,4   | sort -n -t , | tr "," "-"  | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  CIDs:      `cat $WorkDir/cells.INT.side2.csv | tr "-" "," | cut -d , -f 5       | sort -n      | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo "  CGIs:      `cat $WorkDir/cells.INT.side2.csv | tr "-" "," | cut -d , -f 2,3,4,5 | sort -n -t , | tr "," "-"  | tr "\n" " " | awk '{print $1" .. "$(NF)}'`"
echo ""

# Calc offset for MNC values
MinMaxMNC1=`cat $WorkDir/cells.INT.side1.csv | tr "-" "," | cut -d , -f 3 |
    sort -n -u | tr "\n" " " | awk '{print $1,$(NF)}'`
MinMaxMNC2=`cat $WorkDir/cells.INT.side2.csv | tr "-" "," | cut -d , -f 3 |
    sort -n -u | tr "\n" " " | awk '{print $1,$(NF)}'`
OffsetMNC=`echo $MinMaxMNC1 $MinMaxMNC2 |
    awk '{
            Min1=$1; Max1=$2;   Min2=$3; Max2=$4;
            if(Max1<Min2 || Min1>Max2)
                OffsetMNC2 = 0
            else
                OffsetMNC2 = int((Max1-Min2)/10)*10+10
            print OffsetMNC2
        }'`
echo "Offset of MNC values for side 2: $OffsetMNC"
echo ""

# Side 2, internal GSM cells
#   update MNC value
awk -F , -v OffsetMNC=$OffsetMNC \
    '{
        split($2,cgi,"-");
        L      = length(cgi[2]);
        NewMNC = cgi[2] + OffsetMNC;
        # IntName2,OldCGI2,NewCGI2
        printf "%s,%s-%s-%s-%s\n",$0,cgi[1],NewMNC,cgi[3],cgi[4]
    }' $WorkDir/cells.INT.side2.csv > $IntCellsMap2

# Side 1, external GSM cells
#   get the cell name from the same external GSM cell on side 2
#   get the updated CGI value from the corresponding internal GSM cell on side 2
awk -F , -v IntCellsPath2=$IntCellsMap2 \
    -v ExtCellsPath2=$WorkDir/cells.EXT.side2.csv \
    'BEGIN{
        extCell2_idx2name["-"] = "-"
        extCell2_idx2oldcgi["-"] = "-"
        intCell2_oldcgi2newcgi["-"] = "-"
        NumIntCells2=0
        NumExtCells2=0
        # IntName2,OldCGI2,NewCGI2
        while((getline < IntCellsPath2) > 0) {
            NumIntCells2+=1
            intCell2_oldcgi2newcgi[$2] = $3
        }
        # ExtName2,OldCGI2
        while((getline < ExtCellsPath2) > 0) {
            NumExtCells2+=1
            extCell2_idx2name[NumExtCells2] = $1
            extCell2_idx2oldcgi[NumExtCells2] = $2
        }
        ExtCellIdx1=0
    }
    {
        ++ExtCellIdx1
        ExtName2   = extCell2_idx2name[ExtCellIdx1]
        OldExtCGI2 = extCell2_idx2oldcgi[ExtCellIdx1]
        NewIntCGI2 = intCell2_oldcgi2newcgi[OldExtCGI2]
        # OldExtName1,OldCGI1,NewExtName1,NewCGI1
        printf "%s,%s,%s\n",$0,ExtName2,NewIntCGI2
    }' $WorkDir/cells.EXT.side1.csv > $ExtCellsMap1

# Side 2, external GSM cells
#   get the cell name from the same external GSM cell on side 1
#   get the CGI value from the same external GSM cell on side 1
awk -F , -v ExtCellsPath1=$WorkDir/cells.EXT.side1.csv \
    'BEGIN{
        extCell1_idx2name["-"] = "-"
        extCell1_idx2cgi["-"] = "-"
        NumExtCells1=0
        # ExtName1,OldCGI1
        while((getline < ExtCellsPath1) > 0) {
            NumExtCells1+=1
            extCell1_idx2name[NumExtCells1] = $1
            extCell1_idx2cgi[NumExtCells1] = $2
        }
        ExtCellIdx2=0
    }
    {
        ++ExtCellIdx2
        ExtName1 = extCell1_idx2name[ExtCellIdx2]
        ExtCGI1  = extCell1_idx2cgi[ExtCellIdx2]
        # OldExtName2,OldCGI2,NewExtName2,NewCGI2
        printf "%s,%s,%s\n",$0,ExtName1,ExtCGI1
    }' $WorkDir/cells.EXT.side2.csv > $ExtCellsMap2


# ___ Postprocessing ___________________________________________________________

